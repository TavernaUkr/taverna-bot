# -*- coding: utf-8 -*-
"""
Bot with FSM (real & test modes)
- Aiogram bot with FSM for orders
- Telethon reposts supplier posts with +33% markup
- MyDrop integration: real vs test mode
- Nova Poshta API integration
- Flask healthcheck
"""

import os
import sys
import json
import asyncio
import logging
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, List
import re
import io

import aiohttp
from dotenv import load_dotenv
from flask import Flask

from aiogram import Bot, Dispatcher, Router, F
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    Message, CallbackQuery,
    InlineKeyboardButton, InlineKeyboardMarkup,
)

from telethon import TelegramClient

# ---------------- Config & Env ----------------
load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("taverna")

def check_env_vars():
    print("=== Checking ENV variables ===")
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    if not BOT_TOKEN:
        print("‚ùå ERROR: BOT_TOKEN is missing")
        sys.exit(1)

    env_vars = [
        "BOT_TOKEN", "BOT_USERNAME", "ADMIN_ID",
        "TEST_CHANNEL", "MAIN_CHANNEL", "TG_API_ID", "TG_API_HASH",
        "SESSION_NAME", "SUPPLIER_CHANNEL", "SUPPLIER_NAME",
        "NP_API_KEY", "NP_API_URL", "MYDROP_API_KEY", "MYDROP_EXPORT_URL", "MYDROP_ORDERS_URL", "ORDERS_DIR", "USE_GCS", "GCS_BUCKET",
        "SERVICE_ACCOUNT_JSON", "USE_GDRIVE", "GDRIVE_FOLDER_ID", "TEST_MODE"
    ]
    for var in env_vars:
        value = os.getenv(var)
        if value:
            print(f"‚úÖ {var} = {str(value)[:40]}...")
        else:
            print(f"‚ö†Ô∏è {var} is not set")
    print("=== End ENV check ===")
    return BOT_TOKEN

BOT_TOKEN = check_env_vars()
BOT_USERNAME = os.getenv("BOT_USERNAME")
ADMIN_ID = int(os.getenv("ADMIN_ID", "0"))
TEST_CHANNEL = os.getenv("TEST_CHANNEL")
MAIN_CHANNEL = os.getenv("MAIN_CHANNEL")

api_id = int(os.getenv("TG_API_ID", "0") or 0)
api_hash = os.getenv("TG_API_HASH", "")
SESSION_NAME = os.getenv("SESSION_NAME", "bot1")
supplier_channel = os.getenv("SUPPLIER_CHANNEL")
supplier_name = os.getenv("SUPPLIER_NAME", "Supplier")

NP_API_KEY = os.getenv("NP_API_KEY")
NP_API_URL = os.getenv("NP_API_URL")

MYDROP_API_KEY = os.getenv("MYDROP_API_KEY")
MYDROP_EXPORT_URL = os.getenv("MYDROP_EXPORT_URL")
MYDROP_ORDERS_URL = os.getenv("MYDROP_ORDERS_URL")

ORDERS_DIR = os.getenv("ORDERS_DIR", "/tmp/orders")
Path(ORDERS_DIR).mkdir(parents=True, exist_ok=True)

TEST_MODE = os.getenv("TEST_MODE", "false").lower() == "true"

# ---------------- Cache for MyDrop products ----------------
PRODUCTS_CACHE = {
    "last_update": None,
    "data": None
}
CACHE_TTL = 900  # 15 —Ö–≤–∏–ª–∏–Ω (900 —Å–µ–∫—É–Ω–¥)

# ---------------- Flask ----------------
app = Flask(__name__)

@app.route("/")
def index():
    return "Bot is running!", 200

@app.route("/healthz")
def healthz():
    logger.info("üîÑ Healthcheck –∑–∞–ø–∏—Ç –æ—Ç—Ä–∏–º–∞–Ω–æ (keepalive ping).")
    return "ok", 200

def run_flask():
    port = int(os.getenv("PORT", 10000))
    logging.info(f"üåê Flask healthcheck running on port {port}")
    app.run(host="0.0.0.0", port=port)

# ---------------- Aiogram bot ----------------
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)
from aiogram.types import BotCommand

async def setup_commands():
    commands = [
        BotCommand(command="start", description="–ü–æ—á–∞—Ç–∏ —Ä–æ–±–æ—Ç—É –∑ –±–æ—Ç–æ–º"),
        BotCommand(command="publish_test", description="–û–ø—É–±–ª—ñ–∫—É–≤–∞—Ç–∏ —Ç–µ—Å—Ç–æ–≤–∏–π –ø–æ—Å—Ç (–∞–¥–º—ñ–Ω)"),
        BotCommand(command="refresh_cache", description="–û–Ω–æ–≤–∏—Ç–∏ –∫–µ—à –≤–∏–≥—Ä—É–∑–∫–∏ (–∞–¥–º—ñ–Ω)"),
    ]
    try:
        await bot.set_my_commands(commands)
    except Exception as e:
        logger.exception("Cannot set bot commands: %s", e)

# ---------------- FSM ----------------
class OrderForm(StatesGroup):
    pib = State()
    phone = State()
    article = State()
    amount = State()
    delivery = State()
    address = State()
    payment = State()
    note = State()
    confirm = State()

# ---------------- Helpers: keyboards ----------------
def get_order_keyboard(post_id: int, test: bool = False):
    mode = "test" if test else "real"
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üõí –ó–∞–º–æ–≤–∏—Ç–∏", url=f"https://t.me/{BOT_USERNAME}?start=order_{mode}_{post_id}")]
        ]
    )

def delivery_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üöö –ù–æ–≤–∞ –ü–æ—à—Ç–∞", callback_data="delivery:np")],
        [InlineKeyboardButton(text="üìÆ –£–∫—Ä –ü–æ—à—Ç–∞", callback_data="delivery:ukr")],
        [InlineKeyboardButton(text="üõí Rozetka", callback_data="delivery:rozetka")],
        [InlineKeyboardButton(text="üì¶ Justin", callback_data="delivery:justin")],
        [InlineKeyboardButton(text="‚úàÔ∏è Meest", callback_data="delivery:meest")],
    ])

def payment_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üíµ –ù–∞–∫–ª–∞–¥–µ–Ω–∏–π –ø–ª–∞—Ç—ñ–∂", callback_data="pay:cod")],
        [InlineKeyboardButton(text="üí≥ –ü–æ–≤–Ω–∞ –ø–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞", callback_data="pay:full")],
        [InlineKeyboardButton(text="üí∏ –ß–∞—Å—Ç–∫–æ–≤–∞ –ø–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ (33%)", callback_data="pay:part")],
    ])

def confirm_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏", callback_data="order:confirm")],
        [InlineKeyboardButton(text="‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="order:cancel")]
    ])

# ---------------- Routers / Handlers ----------------
@router.message(CommandStart(deep_link=True))
async def cmd_start(msg: Message, state: FSMContext, command: CommandStart):
    args = command.args or ""
    if args.startswith("order_"):
        parts = args.split("_")
        if len(parts) == 3:
            mode, post_id = parts[1], parts[2]
            await state.update_data(post_message_id=post_id, mode=mode)
            await msg.answer("üßæ –†–æ–∑–ø–æ—á–Ω–µ–º–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è. –í–≤–µ–¥—ñ—Ç—å –≤–∞—à—ñ –ü–Ü–ë:")
            await state.set_state(OrderForm.pib)
            return
    await msg.answer(
        "–ü—Ä–∏–≤—ñ—Ç! –¶–µ –±–æ—Ç Taverna üëã\n"
        "–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É ¬´–ó–∞–º–æ–≤–∏—Ç–∏¬ª –ø—ñ–¥ –ø–æ—Å—Ç–æ–º —É –∫–∞–Ω–∞–ª—ñ, —â–æ–± –æ—Ñ–æ—Ä–º–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è."
    )

# ---------------- Test command ----------------
@router.message(Command("publish_test"))
async def cmd_publish_test(msg: Message):
    if msg.from_user.id != ADMIN_ID:
        await msg.answer("‚ö†Ô∏è –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –Ω–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
        return
    text = (
        "üî• <b>–¢–µ—Å—Ç–æ–≤–∏–π –ø–æ—Å—Ç –¥–ª—è</b> @test_taverna\n\n"
        "–¶–µ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–Ω–æ–ø–∫–∏ <b>¬´–ó–∞–º–æ–≤–∏—Ç–∏¬ª</b>.\n"
        "–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å —ñ –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Ñ–æ—Ä–º—É –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è."
    )
    kb = get_order_keyboard(post_id=12345, test=True)  # test=True -> order_test_xxx
    try:
        await bot.send_message(TEST_CHANNEL, text, reply_markup=kb)
        await msg.answer("‚úÖ –¢–µ—Å—Ç–æ–≤–∏–π –ø–æ—Å—Ç –æ–ø—É–±–ª—ñ–∫–æ–≤–∞–Ω–æ –≤ —Ç–µ—Å—Ç–æ–≤–æ–º—É –∫–∞–Ω–∞–ª—ñ.")
    except Exception as e:
        await msg.answer(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó: {e}")

@router.message(Command("refresh_cache"))
async def cmd_refresh_cache(msg: Message):
    if msg.from_user.id != ADMIN_ID:
        await msg.answer("‚ö†Ô∏è –£ –≤–∞—Å –Ω–µ–º–∞—î –ø—Ä–∞–≤ –Ω–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
        return
    """–ü—Ä–∏–º—É—Å–æ–≤–æ –æ–Ω–æ–≤–ª—é—î –∫–µ—à –≤–∏–≥—Ä—É–∑–∫–∏ —Ç–æ–≤–∞—Ä—ñ–≤"""
    await msg.answer("‚è≥ –û–Ω–æ–≤–ª—é—é –∫–µ—à –≤–∏–≥—Ä—É–∑–∫–∏...")
    text = await load_products_export(force=True)
    if text:
        await msg.answer("‚úÖ –ö–µ—à –æ–Ω–æ–≤–ª–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ.")
    else:
        await msg.answer("‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ –∫–µ—à—É. –ü–µ—Ä–µ–≤—ñ—Ä –ª–æ–≥–∏.")

# --- –ü–Ü–ë ---
@router.message(OrderForm.pib)
async def state_pib(msg: Message, state: FSMContext):
    if len(msg.text.split()) < 3:
        await msg.answer("‚ùå –í–≤–µ–¥—ñ—Ç—å –ø–æ–≤–Ω–µ –ü–Ü–ë (–ü—Ä—ñ–∑–≤–∏—â–µ –Ü–º'—è –ü–æ-–±–∞—Ç—å–∫–æ–≤—ñ).")
        return
    await state.update_data(pib=msg.text)
    await msg.answer("–í–≤–µ–¥—ñ—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω (—É —Ñ–æ—Ä–º–∞—Ç—ñ +380XXXXXXXXX):")
    await state.set_state(OrderForm.phone)

# --- –¢–µ–ª–µ—Ñ–æ–Ω ---
@router.message(OrderForm.phone)
async def state_phone(msg: Message, state: FSMContext):
    phone = msg.text.strip()
    if not re.match(r"^\+380\d{9}$", phone):
        await msg.answer("‚ùå –¢–µ–ª–µ—Ñ–æ–Ω –º–∞—î –±—É—Ç–∏ —É —Ñ–æ—Ä–º–∞—Ç—ñ +380XXXXXXXXX.")
        return
    await state.update_data(phone=phone)
    await msg.answer("–í–≤–µ–¥—ñ—Ç—å –∞—Ä—Ç–∏–∫—É–ª –∞–±–æ –Ω–∞–∑–≤—É —Ç–æ–≤–∞—Ä—É:")
    await state.set_state(OrderForm.article)

async def load_products_export(force: bool = False) -> Optional[str]:
    """
    –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î –≤–∏–≥—Ä—É–∑–∫—É –∑ MYDROP_EXPORT_URL (YML/JSON) –∑ –∫–µ—à–µ–º.
    –Ø–∫—â–æ force=True ‚Äî –∫–∞—á–∞—î –∑–∞–Ω–æ–≤–æ –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ –∫–µ—à —â–µ –∞–∫—Ç—É–∞–ª—å–Ω–∏–π.
    """
    global PRODUCTS_CACHE
    now = datetime.now()

    # –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∫–µ—à, —è–∫—â–æ –≤—ñ–Ω —Å–≤—ñ–∂–∏–π
    if not force and PRODUCTS_CACHE["last_update"] and (now - PRODUCTS_CACHE["last_update"]).seconds < CACHE_TTL:
        return PRODUCTS_CACHE["data"]

    export_url = os.getenv("MYDROP_EXPORT_URL")
    if not export_url:
        logger.error("‚ùå MYDROP_EXPORT_URL –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π")
        return None

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(export_url, timeout=20) as resp:
                if resp.status != 200:
                    logger.warning("‚ö†Ô∏è Export URL error %s", resp.status)
                    return None
                text = await resp.text()

                PRODUCTS_CACHE["last_update"] = now
                PRODUCTS_CACHE["data"] = text

                # –∑–±–µ—Ä–µ–∂–µ–º–æ —É —Ñ–∞–π–ª (–±–µ–∫–∞–ø)
                cache_file = Path(ORDERS_DIR) / "products_cache.xml"
                cache_file.write_text(text, encoding="utf-8")

                logger.info("‚úÖ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –Ω–æ–≤—É –≤–∏–≥—Ä—É–∑–∫—É (%d —Å–∏–º–≤–æ–ª—ñ–≤)", len(text))
                return text
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤–∏–≥—Ä—É–∑–∫–∏: %s", e)

        # fallback ‚Äî –±–µ—Ä–µ–º–æ –∑ –∫–µ—à-—Ñ–∞–π–ª—É
        cache_file = Path(ORDERS_DIR) / "products_cache.xml"
        if cache_file.exists():
            return cache_file.read_text(encoding="utf-8")

        return None

# --- –ê—Ä—Ç–∏–∫—É–ª –∞–±–æ –Ω–∞–∑–≤–∞ ---
import io
import xml.etree.ElementTree as ET
from typing import Optional, Dict, Any

def apply_markup(price: Optional[float]) -> Optional[int]:
    """–î–æ–¥–∞—î +33% –¥–æ —Ü—ñ–Ω–∏ —ñ –æ–∫—Ä—É–≥–ª—é—î –¥–æ –≥—Ä–∏–≤–Ω—ñ (int)."""
    try:
        if price is None:
            return None
        return int(round(float(price) * 1.33))
    except Exception:
        return None

async def check_article_or_name(query: str) -> Optional[Dict[str, Any]]:
    """
    –®—É–∫–∞—î —Ç–æ–≤–∞—Ä –ø–æ –∞—Ä—Ç–∏–∫—É–ª—É –∞–±–æ –Ω–∞–∑–≤—ñ —É –≤–∏–≥—Ä—É–∑—Ü—ñ (MYDROP_EXPORT_URL).
    –ü–æ–≤–µ—Ä—Ç–∞—î dict –∑ –ø–æ–ª—è–º–∏:
      - name, sku, drop_price (float|None), retail_price (float|None),
      - final_price (int|None) ‚Äî –∫–ª—ñ—î–Ω—Ç—Å—å–∫–∞ —Ü—ñ–Ω–∞ = drop_price*1.33 –æ–∫—Ä—É–≥–ª–µ–Ω–æ,
      - stock (str), sizes (list[str]) –∞–±–æ None,
      - suggestion (bool) —è–∫—â–æ —Ü–µ —á–∞—Å—Ç–∫–æ–≤–∏–π –∑–±—ñ–≥.
    –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î ET.iterparse –¥–ª—è –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ.
    """
    q = str(query or "").strip().lower()
    if not q:
        return None

    text = await load_products_export()
    if not text:
        return None

    try:
        it = ET.iterparse(io.StringIO(text), events=("end",))
        for event, elem in it:
            # –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–µ–≥–∞ (–±–µ–∑ namespace)
            tag = elem.tag
            if tag.endswith("offer") or tag.endswith("item") or tag.endswith("product"):
                offer_id = (elem.attrib.get("id") or "").strip()
                vendor_code = (elem.findtext("vendorCode") or elem.findtext("sku") or "").strip()
                name = (elem.findtext("name") or elem.findtext("title") or "").strip()
                price_text = elem.findtext("price") or ""
                try:
                    drop_price = float(price_text) if price_text.strip() else None
                except Exception:
                    drop_price = None
                # retail price (RRC) –º–æ–∂–µ –±—É—Ç–∏ –≤ —Ä—ñ–∑–Ω–∏—Ö –ø–æ–ª—è—Ö
                rrc_text = elem.findtext("rrc") or elem.findtext("retail") or elem.findtext("oldprice") or None
                try:
                    retail_price = float(rrc_text) if rrc_text and str(rrc_text).strip() else None
                except Exception:
                    retail_price = None

                # –∫—ñ–ª—å–∫—ñ—Å—Ç—å —É –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ
                quantity_text = elem.findtext("quantity_in_stock")
                stock_qty = None
                if quantity_text and quantity_text.strip().isdigit():
                    stock_qty = int(quantity_text.strip())

                # —è–∫—â–æ –Ω–µ–º–∞ –∫—ñ–ª—å–∫–æ—Å—Ç—ñ ‚Äî fallback –Ω–∞ available
                stock_attr = elem.attrib.get("available", "true").lower()
                stock = "–Ñ" if stock_attr in ("true", "1", "yes") else "–ù–µ–º–∞—î"

                # size params: —à—É–∫–∞—î–º–æ param name=... —è–∫—ñ –º—ñ—Å—Ç—è—Ç—å 'size' –∞–±–æ '—Ä–æ–∑–º—ñ—Ä'
                sizes = []
                for p in elem.findall("param"):
                    pname = p.attrib.get("name", "").lower()
                    if "size" in pname or "—Ä–æ–∑–º—ñ—Ä" in pname or "—Ä–∞–∑–º–µ—Ä" in pname:
                        if (p.text or "").strip():
                            sizes.append(p.text.strip())

                # --- 1) —Ç–æ—á–Ω–∏–π –ø–æ—à—É–∫ –ø–æ –∞—Ä—Ç–∏–∫—É–ª—É (id –∞–±–æ vendorCode) ---
                if q == offer_id.lower() or (vendor_code and q == vendor_code.lower()):
                    elem.clear()
                    return {
                        "name": name or offer_id,
                        "sku": vendor_code or offer_id,
                        "drop_price": drop_price,
                        "retail_price": retail_price,
                        "final_price": apply_markup(drop_price) if drop_price is not None else None,
                        "stock": stock,
                        "stock_qty": stock_qty,
                        "sizes": sizes or None
                    }

                # --- 2) —Ç–æ—á–Ω–∏–π –ø–æ—à—É–∫ –ø–æ –Ω–∞–∑–≤—ñ ---
                if name and q == name.lower():
                    elem.clear()
                    return {
                        "name": name,
                        "sku": vendor_code or offer_id,
                        "drop_price": drop_price,
                        "retail_price": retail_price,
                        "final_price": apply_markup(drop_price) if drop_price is not None else None,
                        "stock": stock,
                        "stock_qty": stock_qty,
                        "sizes": sizes or None
                    }

                # --- 3) —á–∞—Å—Ç–∫–æ–≤–∏–π –ø–æ—à—É–∫ –ø–æ –Ω–∞–∑–≤—ñ (–ø–µ—Ä—à–∏–π –∑–±—ñ–≥) ---
                if name and q in name.lower() and len(q) >= 3:
                    elem.clear()
                    return {
                        "suggestion": True,
                        "name": name,
                        "sku": vendor_code or offer_id,
                        "drop_price": drop_price,
                        "retail_price": retail_price,
                        "final_price": apply_markup(drop_price) if drop_price is not None else None,
                        "stock": stock,
                        "sizes": sizes or None
                    }

                # –æ—á–∏—â–µ–Ω–Ω—è –¥–ª—è –µ–∫–æ–Ω–æ–º—ñ—ó –ø–∞–º'—è—Ç—ñ
                elem.clear()
        # –∫—ñ–Ω–µ—Ü—å —ñ—Ç–µ—Ä–∞—Ü—ñ—ó
    except Exception as e:
        logger.exception("XML parse error in check_article_or_name: %s", e)

    return None

# --- FSM: –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∞—Ä—Ç–∏–∫—É–ª—É –∞–±–æ –Ω–∞–∑–≤–∏ ---
@router.message(OrderForm.article)
async def state_article(msg: Message, state: FSMContext):
    query = msg.text.strip()
    await msg.chat.do("typing")
    product = await check_article_or_name(query)

    if not product:
        await msg.answer("‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ç–æ–≤–∞—Ä. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ (–∞—Ä—Ç–∏–∫—É–ª –∞–±–æ —á–∞—Å—Ç–∏–Ω–∞ –Ω–∞–∑–≤–∏) –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å '–ø—ñ–¥—Ç—Ä–∏–º–∫–∞'.")
        return

    stock_text = (
    f"{product['stock']} ({product['stock_qty']} —à—Ç.)"
    if product.get("stock_qty") is not None
    else product["stock"]
)

    # –Ø–∫—â–æ —Ü–µ –ª–∏—à–µ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—è (—á–∞—Å—Ç–∫–æ–≤–∏–π –∑–±—ñ–≥)
    if product.get("suggestion"):
        sizes_text = f"\nüìè –†–æ–∑–º—ñ—Ä–∏: {', '.join(product['sizes'])}" if product.get("sizes") else ""
        await msg.answer(
            f"ü§î –ú–æ–∂–ª–∏–≤–æ –≤–∏ –º–∞–ª–∏ –Ω–∞ —É–≤–∞–∑—ñ:\n"
            f"üîñ <b>{product['name']}</b>\n"
            f"üÜî –ê—Ä—Ç–∏–∫—É–ª: <b>{product['sku']}</b>\n"
            f"üì¶ –ù–∞—è–≤–Ω—ñ—Å—Ç—å: <b>{stock_text}</b>\n"
            f"üí∞ –û—Ä—ñ—î–Ω—Ç–æ–≤–Ω–∞ —Ü—ñ–Ω–∞ (–∑ –Ω–∞—Ü—ñ–Ω–∫–æ—é): {product.get('final_price') or '‚Äî'} –≥—Ä–Ω\n"
            f"üíµ –î—Ä–æ–ø —Ü—ñ–Ω–∞: {product.get('drop_price') or '‚Äî'} –≥—Ä–Ω"
            f"{sizes_text}\n\n"
            "–Ø–∫—â–æ —Ü–µ —Ç–µ, —â–æ —Ç—Ä–µ–±–∞ ‚Äî –≤–≤–µ–¥—ñ—Ç—å –∞—Ä—Ç–∏–∫—É–ª –¥–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è."
        )
        return

    # –Ø–∫—â–æ —Ç–æ—á–Ω–∏–π –∑–±—ñ–≥
    sizes_text = f"\nüìè –†–æ–∑–º—ñ—Ä–∏: {', '.join(product['sizes'])}" if product.get("sizes") else ""
    await state.update_data(
        article=product["sku"],
        product_name=product["name"],
        stock=product["stock"],
        stock_qty=product.get("stock_qty"),
        price=product["final_price"]
    )
    await msg.answer(
        f"‚úÖ –ó–Ω–∞–π–¥–µ–Ω–æ —Ç–æ–≤–∞—Ä:\n"
        f"üîñ <b>{product['name']}</b>\n"
        f"üÜî –ê—Ä—Ç–∏–∫—É–ª: <b>{product['sku']}</b>\n"
        f"üì¶ –ù–∞—è–≤–Ω—ñ—Å—Ç—å: <b>{stock_text}</b>\n"
        f"üí∞ –¶—ñ–Ω–∞ –¥–ª—è –∫–ª—ñ—î–Ω—Ç–∞: {product.get('final_price') or '‚Äî'} –≥—Ä–Ω\n"
        f"üíµ –î—Ä–æ–ø —Ü—ñ–Ω–∞: {product.get('drop_price') or '‚Äî'} –≥—Ä–Ω"
        f"{sizes_text}\n\n"
        "üëâ –í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ–≤–∞—Ä—É (—á–∏—Å–ª–æ):",
    )
    await state.set_state(OrderForm.amount)

# --- –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ–≤–∞—Ä—É ---
@router.message(OrderForm.amount)
async def state_amount(msg: Message, state: FSMContext):
    try:
        qty = int(msg.text.strip())
        if qty < 1:
            raise ValueError
    except ValueError:
        await msg.answer("‚ùå –í–≤–µ–¥—ñ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–µ —á–∏—Å–ª–æ (–º—ñ–Ω—ñ–º—É–º 1).")
        return

    data = await state.get_data()
    max_stock = data.get("stock_qty")

    # —è–∫—â–æ —î —Ä–µ–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —É stock_qty
    if max_stock is not None and qty > max_stock:
        await msg.answer(
            f"‚ö†Ô∏è –î–æ—Å—Ç—É–ø–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ü—å–æ–≥–æ —Ç–æ–≤–∞—Ä—É: <b>{max_stock} —à—Ç.</b>\n"
            f"–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —ñ–Ω—à—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å:"
        )
        return  # –∑–∞–ª–∏—à–∞—î–º–æ —É —Ü—å–æ–º—É –∂ —Å—Ç–∞–Ω—ñ

    # —è–∫—â–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω–∞ ‚Äî –∑–±–µ—Ä—ñ–≥–∞—î–º–æ
    await state.update_data(amount=qty)
    await msg.answer("–û–±–µ—Ä—ñ—Ç—å —Å–ª—É–∂–±—É –¥–æ—Å—Ç–∞–≤–∫–∏:", reply_markup=delivery_keyboard())
    await state.set_state(OrderForm.delivery)

# --- –î–æ—Å—Ç–∞–≤–∫–∞ ---
@router.callback_query(F.data.startswith("delivery:"))
async def cb_delivery(cb: CallbackQuery, state: FSMContext):
    delivery = cb.data.split(":")[1]
    await state.update_data(delivery=delivery)
    if delivery == "np":
        await cb.message.answer("–í–≤–µ–¥—ñ—Ç—å –º—ñ—Å—Ç–æ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ (–ù–æ–≤–∞ –ü–æ—à—Ç–∞):")
        await state.set_state(OrderForm.address)
    else:
        await cb.message.answer("–í–≤–µ–¥—ñ—Ç—å –∞–¥—Ä–µ—Å—É/–≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –¥–æ—Å—Ç–∞–≤–∫–∏:")
        await state.set_state(OrderForm.address)
    await cb.answer()

@router.message(OrderForm.address)
async def state_address(msg: Message, state: FSMContext):
    await state.update_data(address=msg.text)
    await msg.answer("–û–±–µ—Ä—ñ—Ç—å —Ç–∏–ø –æ–ø–ª–∞—Ç–∏:", reply_markup=payment_keyboard())
    await state.set_state(OrderForm.payment)

# --- –û–ø–ª–∞—Ç–∞ ---
@router.callback_query(F.data.startswith("pay:"))
async def cb_payment(cb: CallbackQuery, state: FSMContext):
    payment = cb.data.split(":")[1]
    await state.update_data(payment=payment)
    await cb.message.answer("–î–æ–¥–∞–π—Ç–µ –ø—Ä–∏–º—ñ—Ç–∫—É (–∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å '–Ω–µ–º–∞'):")
    await state.set_state(OrderForm.note)
    await cb.answer()

# --- –ü—Ä–∏–º—ñ—Ç–∫–∞ ---
@router.message(OrderForm.note)
async def state_note(msg: Message, state: FSMContext):
    note = msg.text.strip()
    await state.update_data(note=note)
    await msg.answer("–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –¥–∞–Ω—ñ —Ç–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥—ñ—Ç—å –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è:", reply_markup=confirm_keyboard())
    await state.set_state(OrderForm.confirm)

# --- –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è ---
@router.callback_query(F.data == "order:confirm")
async def cb_order_confirm(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    order_text = (
        "üì¶ –ù–û–í–ï –ó–ê–ú–û–í–õ–ï–ù–ù–Ø\n\n"
        f"üë§ –ü–Ü–ë: {data.get('pib')}\n"
        f"üìû –¢–µ–ª–µ—Ñ–æ–Ω: {data.get('phone')}\n"
        f"üîñ –¢–æ–≤–∞—Ä: {data.get('product_name')} (SKU: {data.get('article')})\n"
        f"üì¶ –ù–∞—è–≤–Ω—ñ—Å—Ç—å: {data.get('stock')} —à—Ç.\n"
        f"üî¢ –ö—ñ–ª—å–∫—ñ—Å—Ç—å: {data.get('amount', 1)} —à—Ç.\n"
        f"üöö –°–ª—É–∂–±–∞: {data.get('delivery')}\n"
        f"üìç –ê–¥—Ä–µ—Å–∞/–≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è: {data.get('address')}\n"
        f"üí≥ –¢–∏–ø –æ–ø–ª–∞—Ç–∏: {data.get('payment')}\n"
        f"üìù –ü—Ä–∏–º—ñ—Ç–∫–∞: {data.get('note')}\n"
        f"üïí –ß–∞—Å: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    )
    await cb.message.edit_text(order_text)
    await cb.answer()

    if data.get("mode") == "test":
        link = f"https://mydrop.com.ua/orders/new?prefill={json.dumps(data)}"
        kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="üîó –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ñ–æ—Ä–º—É MyDrop", url=link)]])
        await bot.send_message(ADMIN_ID, f"–¢–µ—Å—Ç–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è:\n{order_text}", reply_markup=kb)
    else:
        asyncio.create_task(create_mydrop_order(data, notify_chat=ADMIN_ID))

    await state.clear()

@router.callback_query(F.data == "order:cancel")
async def cb_order_cancel(cb: CallbackQuery, state: FSMContext):
    await state.clear()
    await cb.message.edit_text("–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.")
    await cb.answer()

# ---------------- MyDrop integration ----------------
async def create_mydrop_order(payload: Dict[str, Any], notify_chat: Optional[int] = None):
    """
    –§–æ—Ä–º—É—î —Ç–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª—è—î –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –≤ MyDrop (dropshipper endpoint).
    –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î MYDROP_ORDERS_URL (POST) —ñ –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-API-KEY = MYDROP_API_KEY
    payload: —Å–ª–æ–≤–Ω–∏–∫ –∑—ñ —Å—Ç–µ–π—Ç—É FSM (–º–∞—î –º—ñ—Å—Ç–∏—Ç–∏ pib, phone, article, product_name, stock, delivery, address, payment, note, mode)
    """
    orders_url = os.getenv("MYDROP_ORDERS_URL")
    api_key = os.getenv("MYDROP_API_KEY")
    if not orders_url or not api_key:
        logger.error("MYDROP_ORDERS_URL or MYDROP_API_KEY not configured")
        if notify_chat:
            await bot.send_message(notify_chat, "‚ö†Ô∏è MYDROP_ORDERS_URL –∞–±–æ MYDROP_API_KEY –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω—ñ –Ω–∞ —Å–µ—Ä–≤–µ—Ä—ñ.")
        return None

    # –°—Ñ–æ—Ä–º—É—î–º–æ products –º–∞—Å–∏–≤ –∑–≥—ñ–¥–Ω–æ –∑ docs (–¥–ª—è dropshipper endpoint)
    article = payload.get("article")
    product_name = payload.get("product_name") or payload.get("title") or article or "–¢–æ–≤–∞—Ä"
    amount = int(payload.get("amount", 1) or 1)
    # –Ø–∫—â–æ —É state –Ω–µ–º–∞—î —Ü—ñ–Ω–∏ ‚Äî –º–æ–∂–Ω–∞ –≤–∫–∞–∑–∞—Ç–∏ 0 –∞–±–æ –Ω–∞–º–∞–≥–∞—Ç–∏—Å—å –≤–∏—Ç—è–≥—Ç–∏ drop_price, –∞–ª–µ –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—Å—Ç—ñ —Å—Ç–∞–≤–∏–º–æ 0
    price = payload.get("price") or 0
    # vendor_name –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–µ ‚Äî –º–æ–∂–Ω–∞ –ø—ñ–¥—Å—Ç–∞–≤–∏—Ç–∏ SUPPLIER_NAME
    vendor_name = os.getenv("SUPPLIER_NAME") or payload.get("vendor_name") or None

    product_obj = {
        "product_title": product_name,
        "sku": article,
        "price": price,
        "amount": amount
    }
    if vendor_name:
        product_obj["vendor_name"] = vendor_name

    # –§–æ—Ä–º—É—î–º–æ body
    body = {
        "name": payload.get("pib"),
        "phone": payload.get("phone"),
        "products": [product_obj],
    }

    # –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–æ–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏
    if payload.get("delivery"):
        body["delivery_service"] = payload.get("delivery")
    if payload.get("address"):
        # —è–∫—â–æ NP ‚Äî –º–æ–∂–µ –±—É—Ç–∏ –º—ñ—Å—Ç–æ + warehouse_number; —Ç—É—Ç –≤ state address –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —Ç–µ, —â–æ –≤–≤—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á
        body["warehouse_number"] = payload.get("address")
    if payload.get("note"):
        body["description"] = payload.get("note")
    if payload.get("mode") == "test":
        body["order_source"] = "Bot Test"

    headers = {
        "X-API-KEY": api_key,
        "Content-Type": "application/json"
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(orders_url, json=body, headers=headers, timeout=20) as resp:
                text = await resp.text()
                try:
                    data = await resp.json()
                except Exception:
                    data = {"raw": text}
                if 200 <= resp.status < 300:
                    logger.info("MyDrop order created: %s", data)
                    if notify_chat:
                        # –∑–±–µ—Ä–µ–º–æ –∫–æ—Ä–æ—Ç–∫—É —ñ–Ω—Ñ—É –¥–ª—è –∞–¥–º—ñ–Ω–∞
                        await bot.send_message(notify_chat, f"‚úÖ –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ MyDrop.\n–í—ñ–¥–ø–æ–≤—ñ–¥—å: {json.dumps(data, ensure_ascii=False)}")
                    return data
                else:
                    logger.error("MyDrop order error %s: %s", resp.status, text)
                    if notify_chat:
                        await bot.send_message(notify_chat, f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –≤ MyDrop (status {resp.status}):\n{text}")
                    return None
    except Exception as e:
        logger.exception("Error creating MyDrop order: %s", e)
        if notify_chat:
            await bot.send_message(notify_chat, f"‚ùå –í–∏–Ω—è—Ç–æ–∫ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ –≤ MyDrop: {e}")
        return None

# ---------------- Telethon client ----------------
telethon_client: Optional[TelegramClient] = None
if api_id and api_hash:
    session_path = SESSION_NAME
    try:
        telethon_client = TelegramClient(session_path, api_id, api_hash)
        logger.info("Telethon client initialized (session=%s)", session_path)
    except Exception:
        logger.exception("Failed init Telethon client")
        telethon_client = None
else:
    logger.warning("Telethon not configured (TG_API_ID/TG_API_HASH missing)")
    telethon_client = None

# ---------------- Main ----------------
async def main():
    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()
    logger.info("Starting aiogram polling...")
    await setup_commands()

    # –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∫–µ—à –∑ —Ñ–∞–π–ª—É, —è–∫—â–æ —î
    cache_file = Path(ORDERS_DIR) / "products_cache.xml"
    if cache_file.exists():
        try:
            PRODUCTS_CACHE["data"] = cache_file.read_text(encoding="utf-8")
            PRODUCTS_CACHE["last_update"] = datetime.fromtimestamp(cache_file.stat().st_mtime)
            logger.info("Loaded products cache from file (size=%d)", len(PRODUCTS_CACHE['data'] or ''))
        except Exception as e:
            logger.exception("Failed to load products cache file: %s", e)

    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped.")
